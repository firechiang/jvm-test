## JVM 参数配置
####
在实际应用中可以将初始堆大小和最大堆大小设置相等，这样可以减少程序运行时垃圾回收次数，从而提高效率。
```bash
-Xmx20m                           #最大堆大小
-Xms5m                            #初始堆大小
-XX:+UseSerialGC                  #串行垃圾回收器
-XX:+PrintGC                      #打印GC日期
-XX:+PrintGCDetails               #打印GC详细信息
-XX:+PrintCommandLineFlags        #打印虚拟机参数
```
####
不同的堆分配，对系统的执行会有一定的影响，应该根据系统的情况合理的配置；
 尽可能的将对象预留在新生代，减少老年代的GC次数（原因：老年代的GC是 "Full GC"（全面GC） 会造成系统停顿，假死）；
   除了可以设置新生代绝对大小（-Xmn），还可以使用（-XX:NewRatio）设置老年代和新生代的比列。
```bash
-Xmx20m                           #最大堆大小
-Xms20m                           #初始堆大小
-Xmn1m                            #初始新生代大小（和 -XX:NewRatio 配置选其中一个），新生代的大小影响老年代大小：堆 = 新生代 + 老年代；这个参数对应用GC影响很大（可以减少GC的次数），一般设置为整个堆空间的1/3或1/4
-XX:NewRatio=2                    #老年代和新生代比列 ，这里就是 老年代 是新生代的两倍
-XX:SurvivorRatio=2               #新生代里面的比例配置  （eden = 2） = （form=1） + （to=1）
-XX:+UseSerialGC                  #串行垃圾回收器
-XX:+PrintGCDetails               #打印GC详细信息
```
####
Eclipse插件 Mat，内存溢出分析工具（可分析 Test03.dump 文件）
```bash
-XX:+HeapDumpOnOutOfMemoryError   #内存溢出时导出整个堆信息
-XX:HeapDumpPath=d:/Test03.dump   #内存溢出时导出整个堆信息存放的地址
```
#####
```bash
-Xss1m                            #线程最大栈空间
```
## GC算法
#### 引用计数法：
```bash
对象被其它所引用时计数器加1，而当引用失效时则减1；弊端：无法处理循环引用的情况，还有就是加减消耗系统性能。
#### 标记清除法：
```
```bash
分标记和清除两个阶段进行处理内存中的对象；弊端：内存空间碎片问题，垃圾回收后的空间不是连续的，不连续的内存空间的工作效率要低于连续的内存空间。
```
#### 复制算法：
```bash
将内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存对象复制到未被使用的内存块中去，然后去清除正在使用的内存块中所有的对象，反复去交换两个内存的角色，以完成垃圾回收。
（java 新生代中的  from 和 to 空间就是使用这种算法）
```
#### 标记压缩法：
```bash
标记压缩法在标记清除法之上做了优化，把存活的对象压缩到内存的一端，而后进行垃圾清理。
（java老年代使用的就是标记压缩法）
```
```bash



```